<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>烬王的技术博客</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://es-7.github.io/blog/"/>
  <updated>2017-12-20T08:50:46.000Z</updated>
  <id>https://es-7.github.io/blog/</id>
  
  <author>
    <name>石其龙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原生继承</title>
    <link href="https://es-7.github.io/blog/2015/07/03/inheirt/"/>
    <id>https://es-7.github.io/blog/2015/07/03/inheirt/</id>
    <published>2015-07-02T16:00:00.000Z</published>
    <updated>2017-12-20T08:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>  js中的继承有多种实现方式，今天我们来分析一下各种继承的方式以及其优缺点。</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>   首先介绍一下原型链的基本概念。<br>   先来理解一下原型、构造函数和实例之间的关系。      </p><ul><li>每个构造函数都有一个原型对象（通过prototype属性）    </li><li>原型对象都包含一个指向构造函数的指针（通过constructor属性）</li><li>实例都包含一个指向原型对象的内部指针（通过隐式__proto__属性）</li></ul><p>   那么，若原型对象被另一个原型的实例覆盖，则此时原型对象将包含一个指向另一个原型对象的指针。按照这样层层递进，就构成了实例与原型的链条。</p><p>   这个概念可能不好理解，请看下面例子：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用原型链继承Parent构造函数</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</span><br><span class="line"><span class="comment">// constructor属性，指向当前的Child构造函数。</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用父类</span></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</span><br><span class="line">parent.sayName(); <span class="comment">// parent name is father!</span></span><br><span class="line"><span class="comment">// 调用子类</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>);</span><br><span class="line">child.sayName(); <span class="comment">// child name is son!</span></span><br><span class="line">child.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(child.age); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></p><p>  例子中通过将Child的原型对象覆盖，将Child与Parent关联起来了。</p><p>  使用原型链继承缺点：</p><ul><li>由于包含引用类型值的原型属性会被所有实例共享，导致修改一个实例引用值，所有的实例对于这个引用全部被修改。请看下面例子：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"super"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Child();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">instance1.name = <span class="string">"sub"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(instance1.name); <span class="comment">// sub</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//red, blue, green, black</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.name); <span class="comment">// super</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//red, blue, green, black</span></span><br></pre></td></tr></table></figure><p>  就像上面的例子所示，当我们new一个新对象时（其过程可查看new一个新对象会发生什么），原型属性会复制一份到我们实例中。对于值类型，实例会复制其名字和值放在另一块内存中；而对于引用类型，实例只是复制了指向它的值的指针。因而修改实例的值类型，不会影响其他实例；但是修改引用类型的值，其他实例也会被影响到。</p><ul><li><p>创建子类型的实例时，并不能在不影响所有对象实例的情况下给超类型的构造函数传递参数。 </p></li><li><p>顺序不当可能会引发问题，如Child.prototype.sayName 必须写在 Child.prototype = new Parent(‘father’); 之后，不然就会被覆盖掉。</p></li></ul><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>  基本思想：在子类型构造函数内部调用超类型构造函数。<br>  还是先看例子：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.doSomthing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent do something!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过call,apply 改变对象的this指向来继承</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>);</span><br><span class="line">child.sayName(); <span class="comment">// child name: son</span></span><br><span class="line">child.doSomthing(); <span class="comment">// TypeError: child.doSomthing is not a function</span></span><br></pre></td></tr></table></figure></p><p> 相当于 Parent 函数在 Child 函数中执行了一遍，并且将所有与 this 绑定的变量都切换到了 Child 上，使用构造函数继承的方式解决了原型链继承的问题：</p><ul><li>实例可以独享一份引用类型的值<br>通过call改变this指向，这样每次执行Parent函数，this指向的都是新的对象。相当于每个新的对象都有一份完整的Parent代码。即每个实例都有一份自己的属性副本。</li></ul><ul><li>可以传参数<br>我们可以通过call函数向Parent传参数   </li></ul><p>构造函数继承也有缺点：</p><ul><li>无法实现函数复用<br>看上面的代码可知，我们只是执行了Parent函数，但是并没有继承它的原型链上的函数。这样会导致若要使用公有函数时，自己定义或者在Parent构造函数中定义，违背了函数复用的初衷。</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承将原型链继承和构造函数继承结合到一起，是最常用的的继承方式。<br>基本思想是：使用原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.doSomthing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent do something!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过call,apply 改变对象的this指向来继承</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);  <span class="comment">// 第二次调用 </span></span><br><span class="line">    <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);  <span class="comment">// 第一次调用</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>);</span><br><span class="line">child.sayName(); <span class="comment">// child name: son</span></span><br><span class="line">child.doSomthing(); <span class="comment">// parent do something!</span></span><br></pre></td></tr></table></figure></p><p>由例子可知，组合继承结合了原型链继承和构造函数继承的优点，既可以拥有属于自己的属性，也有了共同的方法。<br>当然，它也有缺点。</p><ul><li>无论什么情况下，都会调用两次超类型构造函数。一次在创建子类型的原型时；一次在子类型构造函数内部。当第二次调用时，会重写第一次调用时获得的原型属性。</li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>基本思想：借助已有的对象创建新对象，不必通过构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ob = &#123; <span class="attr">name</span>: <span class="string">'李达康'</span>, <span class="attr">friends</span>: [<span class="string">'沙瑞金'</span>, <span class="string">'季昌明'</span>] &#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型式继承  参数o,引用类型值，实质就是一个内存地址</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; obj</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个构造函数F</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 空构造函数F</span></span><br><span class="line">    &#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ob1 = object(ob);</span><br><span class="line">ob1.name = <span class="string">'侯亮明'</span>;</span><br><span class="line">ob1.friends.push(<span class="string">'陈海'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ob1.name); <span class="comment">// 侯亮明</span></span><br><span class="line"><span class="built_in">console</span>.log(ob1.friends); <span class="comment">// ["沙瑞金", "季昌明", "陈海"]</span></span><br><span class="line"><span class="keyword">var</span> ob2 = object(ob);</span><br><span class="line"><span class="built_in">console</span>.log(ob2.name); <span class="comment">// 李达康</span></span><br><span class="line"><span class="built_in">console</span>.log(ob2.friends); <span class="comment">// ["沙瑞金", "季昌明", "陈海"]</span></span><br></pre></td></tr></table></figure><p>可以看出该方法与原型链继承类似，但是写法比它简单。<br>因此，若只是想让一个对象和另一个相似，可以使用这种方法。<br>不过它也存在缺点：</p><ul><li>包含引用类型值的属性始终共享相应的值。</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>基本思想：创建一个仅用于封装继承过程的函数，在内部对对象做相关增强，然后返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ob = &#123; <span class="attr">name</span>: <span class="string">'李达康'</span>, <span class="attr">friends</span>: [<span class="string">'沙瑞金'</span>, <span class="string">'季昌明'</span>] &#125;;</span><br><span class="line"><span class="comment">// 上面再ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个对象</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; o</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createOb</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newob = <span class="built_in">Object</span>.create(o); <span class="comment">// 创建对象</span></span><br><span class="line">    newob.sayname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 增强对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> newob; <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ob1 = createOb(ob);</span><br><span class="line">ob1.sayname(); <span class="comment">// 李达康</span></span><br></pre></td></tr></table></figure><p>这样做相当于构造函数那样，并不是真正的函数复用。而且包含引用类型值的属性依然始终共享相应的值。</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>这个方法属于比较完美的方法。先看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现继承</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; Parent 父类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; Child  子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Parent, Child</span>) </span>&#123;</span><br><span class="line">    Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype); <span class="comment">// 修改</span></span><br><span class="line">    Child.prototype.construtor = Child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">'达康'</span>, <span class="string">'瑞金'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; parentName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, parentName</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, parentName);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line">inheritPrototype(Parent, Child);</span><br><span class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</span><br><span class="line">parent.sayName(); <span class="comment">// parent name: father</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'son'</span>, <span class="string">'father'</span>);</span><br><span class="line">child1.friends.push(<span class="string">'猴子'</span>); <span class="comment">// ["达康", "瑞金", "猴子"]</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.friends);</span><br><span class="line">child1.sayName(); <span class="comment">// child name: son</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'son2'</span>, <span class="string">'father'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.friends); <span class="comment">// ["达康", "瑞金"]</span></span><br><span class="line">child1.sayName(); <span class="comment">// child name: son2</span></span><br></pre></td></tr></table></figure><p>这个方法解决了组合继承调用两次超类型的缺点。</p><p>首先回顾一下组合继承的两次调用：</p><ul><li><p>创建子类型的原型对象时调用（new Parent()）<br>这个过程会主要是new一个对象的过程，它会复制Parent的属性和方法给子类型。</p></li><li><p>在子类型构造函数里调用<br>在构造函数里调用时，又会复制一遍超类型的属性，因而会影响性能。</p></li></ul><p>对于寄生组合式继承方式：</p><ul><li>先将超类型中的原型对象复制一份，再new对象作为子类型的原型对象。这样做，我们只是复制了超类型的原型对象，而对于超类型构造函数里的属性不会复制。因而减少了调用超类型的次数。</li><li>这样做仍然保持原型链不变</li></ul><h3 id="ES6中class实现继承"><a href="#ES6中class实现继承" class="headerlink" title="ES6中class实现继承"></a>ES6中class实现继承</h3><ul><li><p>ES6提供了更接近传统语言”类”的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p></li><li><p>基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到；新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> * @class Parent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of Parent.</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment">     * @memberOf Parent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做点东西</span></span><br><span class="line"><span class="comment">     * @memberOf Parent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    doSomething() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'parent do something!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印名字</span></span><br><span class="line"><span class="comment">     * @memberOf Parent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`parent name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类 继承 父类</span></span><br><span class="line"><span class="comment"> * @class Child</span></span><br><span class="line"><span class="comment"> * @extends &#123;Parent&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of Child.</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; name</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; parentName</span></span><br><span class="line"><span class="comment">     * @memberOf Child</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(name, parentName) &#123;</span><br><span class="line">        <span class="comment">// 调用基类的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(parentName);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印名字 覆盖父类的sayName方法</span></span><br><span class="line"><span class="comment">     * @memberOf Child</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`child name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>, <span class="string">'father'</span>);</span><br><span class="line">child.sayName(); <span class="comment">// child name: son</span></span><br><span class="line">child.doSomething(); <span class="comment">// parent do something!</span></span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</span><br><span class="line">parent.sayName(); <span class="comment">// parent name: father</span></span><br></pre></td></tr></table></figure><p>如果项目中使用到ES6语法开发，推荐使用ES6继承</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  js中的继承有多种实现方式，今天我们来分析一下各种继承的方式以及其优缺点。&lt;/p&gt;
&lt;h3 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title=&quot;原型链继承&quot;&gt;&lt;/a&gt;原型链继承&lt;/h3&gt;&lt;p&gt;   首先介绍一下原型
      
    
    </summary>
    
    
  </entry>
  
</feed>
